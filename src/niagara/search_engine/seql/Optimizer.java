
/**********************************************************************
  $Id: Optimizer.java,v 1.1 2000/05/30 21:03:28 tufte Exp $


  NIAGARA -- Net Data Management System                                 
                                                                        
  Copyright (c)    Computer Sciences Department, University of          
                       Wisconsin -- Madison                             
  All Rights Reserved.                                                  
                                                                        
  Permission to use, copy, modify and distribute this software and      
  its documentation is hereby granted, provided that both the           
  copyright notice and this permission notice appear in all copies      
  of the software, derivative works or modified versions, and any       
  portions thereof, and that both notices appear in supporting          
  documentation.                                                        
                                                                        
  THE AUTHORS AND THE COMPUTER SCIENCES DEPARTMENT OF THE UNIVERSITY    
  OF WISCONSIN - MADISON ALLOW FREE USE OF THIS SOFTWARE IN ITS "        
  AS IS" CONDITION, AND THEY DISCLAIM ANY LIABILITY OF ANY KIND         
  FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.   
                                                                        
  This software was developed with support by DARPA through             
   Rome Research Laboratory Contract No. F30602-97-2-0247.  
**********************************************************************/


package niagara.search_engine.seql;

import java.util.*;
import java.io.*;
import niagara.search_engine.operators.*;
import niagara.search_engine.indexmgr.*;

/**
 * Query Optimizer for XML Search Engine.
 * Optimize a query plan using algebraic reduction
 * and semi-naive evaluation principle.
 * Restructures the query plan to eliminate 
 * redundant set operations.
 * 
 * Current version eliminates only intersections.
 *
 */
public class Optimizer {

    public Optimizer() {
    }

    public static QueryPlan optimize(QueryPlan unoptimizedPlan) {
	QueryPlan optimizedPlan;

	System.out.print("OPTIMIZER: optimizing execution plan... ");
	// optimize a query plan using algebraic reduction
	// and semi-naive evaluation principle.
	// restructures the query plan to eliminate all
	// redundant set operations.
	optimizedPlan = semiNaiveEval(unoptimizedPlan);

	// will do more optimizations later, if needed.
	// e.g cost-based operator reodering, etc. 

	System.out.println("done.");
	return optimizedPlan;
    }

    protected static QueryPlan semiNaiveEval(QueryPlan subtree) {
	//	QueryPlan optimizedPlan;

	AbstractOperator op = subtree.getOperator();
	
	if (op instanceof ANDOp) {
	    // assume LHS's return type is T1,
	    // case 1. RHS = ElementOp(T1):
	    //    remove RHS
	    // case 2. RHS = a binary op
	    //    push up the RHS and trash the root.

	    // ditto for LHS.

	    QueryPlan leftSub = semiNaiveEval(subtree.getChildAt(0));
	    QueryPlan rightSub = semiNaiveEval(subtree.getChildAt(1));
	    AbstractOperator leftOp = leftSub.getOperator();
	    AbstractOperator rightOp = rightSub.getOperator();
    
	    // no need for checking type of inverted lists.
	    // naive plan generated by plan generator is
	    // guaranteed to be type correct.

	    if (leftOp instanceof ElementOp) {
		return rightSub;
	    } else if (rightOp instanceof ElementOp) {
		return leftSub;
	    }
	    
	    QueryPlan parentNode = getParentNode(rightSub);;
	    
	    if (parentNode == null) {
		QueryPlan optimizedPlan = new QueryPlan();
		optimizedPlan.setOperator(new ANDOp());
		optimizedPlan.addChild(leftSub);
		optimizedPlan.addChild(rightSub);

		return optimizedPlan;
	    }

	    AbstractOperator parentOp = parentNode.getOperator();

	    if (!(parentOp instanceof ElementOp)) {
		System.err.println("WIERD!!!");
	    }

	    parentNode.setOperator(leftSub.getOperator());
	    for (int i=0;i<leftSub.numOfChildren();i++) {
		QueryPlan plan = leftSub.getChildAt(i);
		parentNode.addChild(plan);
	    }

	    return rightSub;
	    
	    /*
	} else if (op instanceof EXCEPTOp) {
	} else if (op instanceof OROp) {
	    */
	} else {
	    QueryPlan optimizedPlan = new QueryPlan();
	    optimizedPlan.setOperator(op);
	    for (int i=0;i<subtree.numOfChildren();i++) {
		
		// in fact, the left subtree need not be traversed.
		// buf for the forward compatibility, we do traverse
		// all the subtree here.
		QueryPlan plan = subtree.getChildAt(i);
		optimizedPlan.addChild(semiNaiveEval(plan));
	    }
	    return optimizedPlan;
	}
    }

    public static QueryPlan getParentNode(QueryPlan plan) {
	
	AbstractOperator op = plan.getOperator();

	if (plan.numOfChildren() <= 0) {
	    return plan;
	} else if (!(op instanceof ContainOp) && 
		   //		   !(op instanceof ContainedOp) &&
		   !(op instanceof NotContainOp)) {
	    return null;
	} else {
	    return getParentNode(plan.getChildAt(0));
	}
    }

    public static void main(String args[]) {
	QueryPlan plan = new QueryPlan();
	QueryPlan plan1 = new QueryPlan();
	QueryPlan plan2 = new QueryPlan();
	QueryPlan plan3 = new QueryPlan();
	QueryPlan plan4 = new QueryPlan();
	QueryPlan plan5 = new QueryPlan();
	QueryPlan plan6 = new QueryPlan();
	QueryPlan plan7 = new QueryPlan();
	QueryPlan plan8 = new QueryPlan();
	QueryPlan plan9 = new QueryPlan();
	QueryPlan plan10 = new QueryPlan();
	QueryPlan plan11 = new QueryPlan();
	QueryPlan plan12 = new QueryPlan();
	
	plan.setOperator(new ANDOp());
	
	plan1.setOperator(new ContainOp());
	plan2.setOperator(new ElementOp("book"));
	plan3.setOperator(new StringOp("java"));
	plan1.addChild(plan2);
	plan1.addChild(plan3);

	plan.addChild(plan1);


	plan4.setOperator(new ContainOp());

	plan5.setOperator(new ElementOp("book"));
	plan4.addChild(plan5);
	plan6.setOperator(new OROp());
	plan.addChild(plan6);
	plan4.addChild(plan6);
	plan7.setOperator(new ContainOp());
	plan8.setOperator(new ElementOp("book"));
	plan9.setOperator(new StringOp("java1"));
	plan10.setOperator(new ContainOp());
	plan11.setOperator(new ElementOp("book"));
	plan12.setOperator(new StringOp("java2"));
	plan7.addChild(plan8);
	plan7.addChild(plan9);
	plan10.addChild(plan11);
	plan10.addChild(plan12);

	plan6.addChild(plan7);
	plan6.addChild(plan10);

	try {
	    plan.writeDot(plan.makeDot(), new FileWriter("QEP.dot"));
	} catch (Exception e) { e.printStackTrace(); } 
	
	System.out.println("Optimizing Execution Plan...");
	QueryPlan optimizedPlan = Optimizer.optimize(plan);
	plan = optimizedPlan;
	
	try {
	    plan.writeDot(plan.makeDot(), new FileWriter("QEP_OPT.dot"));
	} catch (Exception e) { e.printStackTrace(); } 
	
	
    }	
      
}
  
    






