
/**********************************************************************
  $Id: ast.java,v 1.1 2000/05/30 21:03:28 tufte Exp $


  NIAGARA -- Net Data Management System                                 
                                                                        
  Copyright (c)    Computer Sciences Department, University of          
                       Wisconsin -- Madison                             
  All Rights Reserved.                                                  
                                                                        
  Permission to use, copy, modify and distribute this software and      
  its documentation is hereby granted, provided that both the           
  copyright notice and this permission notice appear in all copies      
  of the software, derivative works or modified versions, and any       
  portions thereof, and that both notices appear in supporting          
  documentation.                                                        
                                                                        
  THE AUTHORS AND THE COMPUTER SCIENCES DEPARTMENT OF THE UNIVERSITY    
  OF WISCONSIN - MADISON ALLOW FREE USE OF THIS SOFTWARE IN ITS "        
  AS IS" CONDITION, AND THEY DISCLAIM ANY LIABILITY OF ANY KIND         
  FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.   
                                                                        
  This software was developed with support by DARPA through             
   Rome Research Laboratory Contract No. F30602-97-2-0247.  
**********************************************************************/


package niagara.search_engine.seql;

import java.util.*;
import niagara.search_engine.indexmgr.*;
import niagara.search_engine.operators.*;


/**
 * Abstract Syntax Tree definition.
 * Query Plan is recursivley generated by traversing AST nodes
 * and call genPlan() methods.
 *
 */

// abstract superclass; only subclasses are actually created
abstract class ASTNode {
  int 	linenum;
  int	colnum;

  ASTNode(){linenum=-1;colnum=-1;}
  ASTNode(int l,int c){linenum=l;colnum=c;}
  boolean   isNull(){return false;}; // Is this node null?
  void Unparse(int indent){}; 

  QueryPlan genPlan() { return null; };
  QueryPlan genPlan(exprNode attr) { return null; };
 
};

// abstract superclass; only subclasses are actually created
abstract class exprNode extends queryNode {
	exprNode(){super();};
	exprNode(int l,int c){super(l,c);};
	static nullExprNode NULL = new nullExprNode();
};


// This class def probably doesn't need to be changed
class nullNode extends ASTNode {
  nullNode(){super();};
  boolean   isNull(){return true;};
};


class queryNode extends ASTNode {
    queryNode(){super();};
    queryNode(int line, int col){
	super(line,col);
    }
    static nullQueryNode NULL = new nullQueryNode();
};


class conformstoNode extends exprNode {
  conformstoNode(exprNode a, strlitNode l, int line, int col){
    super(line,col);
    query = a;
    dtdname = l;
  }

    /*
  QueryPlan genPlan() {
      QueryPlan plan = new QueryPlan();
      ContainOp operator = new ContainOp();
      plan.setOperator(operator);
      Vector v = new Vector();
      v.addElement(IndexMgr.idxmgr);
      v.addElement(dtdname.strval);
      QueryPlan dtdplan = new QueryPlan();
      dtdplan.setOperator(new DTDOp(v));
      plan.addChild(dtdplan);
      plan.addChild(query.genPlan());
      return plan;
  }
    */

  QueryPlan genPlan(exprNode attr) {
      QueryPlan plan = new QueryPlan();
      ConformstoOp operator = new ConformstoOp();
      plan.setOperator(operator);

      if (query.isNull()) {
	  plan.addChild(attr.genPlan());
      } else {
	  plan.addChild(query.genPlan());
      }

      Vector v = new Vector();
      v.addElement(IndexMgr.idxmgr);
      v.addElement(dtdname.strval);
      QueryPlan dtdplan = new QueryPlan();
      dtdplan.setOperator(new DTDOp(v));
      plan.addChild(dtdplan);

      return plan;
  }

  QueryPlan genPlan() {
      return genPlan(new identNode("@doc", 0, 0));
  }

  exprNode query;
  strlitNode dtdname;
};

class containsNode extends exprNode {
  containsNode(exprNode a, exprNode l, int line, int col){
    super(line,col);
    attr = a;
    exprs = l;
  }

  QueryPlan genPlan() {
    if (exprs instanceof connectorNode) {
      return exprs.genPlan(attr);
    } else {
      QueryPlan plan = new QueryPlan();
      ContainOp operator = new ContainOp();
      plan.setOperator(operator);
      plan.addChild(attr.genPlan());
      //      plan.addChild(exprs.genPlan());
      if (exprs instanceof conformstoNode) {
	  plan.addChild(exprs.genPlan(attr));
      } else {
	  plan.addChild(exprs.genPlan());
      }
      return plan;
    }
  }

  exprNode attr;
  exprNode exprs;
};


class containedinNode extends exprNode {
  containedinNode(exprNode l, exprNode a, int line, int col){
    super(line,col);
    exprs = l;
    attr = a;
  }

  QueryPlan genPlan() {
    QueryPlan plan = new QueryPlan();
    ContainedOp operator = new ContainedOp();
    plan.setOperator(operator);
    plan.addChild(exprs.genPlan());
    plan.addChild(attr.genPlan());
    return plan;
  }
  exprNode exprs;
  exprNode attr;
};

class isexprNode extends exprNode {
  isexprNode(exprNode a, strlitNode l, int line, int col){
    super(line,col);
    attr = a;
    strlit = l;
  }

  QueryPlan genPlan() {
    QueryPlan plan = new QueryPlan();
    ISOp operator = new ISOp();
    plan.setOperator(operator);
    plan.addChild(attr.genPlan());
    plan.addChild(strlit.genPlan());
    return plan;
  }
  exprNode attr;
  strlitNode strlit;
};

class orderNode extends exprNode {
  orderNode(exprNode a, numlitNode l, Integer o, int line, int col){
    super(line,col);
    attr = a;
    numlit = l;
    op = o.intValue();
  }

  QueryPlan genPlan() {
    QueryPlan plan = new QueryPlan();
    String attrstr = null;
    if (attr instanceof identNode) {
      attrstr = ((identNode)attr).idval;
    } else if (attr instanceof strlitNode) {
      attrstr = ((strlitNode)attr).strval;
    } 
    OrderOp operator = new OrderOp(attrstr, op, numlit.doubleval, IndexMgr.idxmgr);
    plan.setOperator(operator);
    //this attr is numeric attr; should handle differently.
    // option1. pass attr itself to orderop
    return plan;
  }
  exprNode attr;
  numlitNode numlit;
  int op;
};

class distanceofNode extends exprNode {
  distanceofNode(exprNode a, exprNode l, Integer o, numlitNode n, int line, int col){
    super(line,col);
    exprs1 = a;
    exprs2 = l;
    op = o.intValue();
    numlit = n;
  }

  QueryPlan genPlan() {
    QueryPlan plan = new QueryPlan();
    
    //should pass int op instead opstr.
    String opstr = null;
    switch(op) {
    case sym.EQ:
      opstr = "="; break;
    case sym.LT:
      opstr = "<"; break;
    case sym.GT:
      opstr = ">"; break;
    case sym.LEQ:
      opstr = "<="; break;
    case sym.GEQ:
      opstr = ">="; break;
    }

    //should pass int op instead opstr.
    DistanceOp operator = new DistanceOp(opstr, numlit.doubleval);
    plan.setOperator(operator);
    plan.addChild(exprs1.genPlan());
    plan.addChild(exprs2.genPlan());
    return plan;
  }
  exprNode exprs1;
  exprNode exprs2;
  int op;
  numlitNode numlit;
};

class orNode extends connectorNode {
  orNode(exprNode a, exprNode l, int line, int col){
    super(line,col);
    exprs1 = a;
    exprs2 = l;
  }

  QueryPlan genPlan() {
      identNode attr = new identNode("@doc",0,0);
      return genPlan(attr);
  }

  QueryPlan genPlan(exprNode attr) {
    QueryPlan plan = new QueryPlan();
    
    OROp operator = new OROp();
    plan.setOperator(operator);
    if (exprs1 instanceof connectorNode) 
      plan.addChild(exprs1.genPlan(attr));
    else {
      QueryPlan containsPlan = new QueryPlan();
      ContainOp cop = new ContainOp();
      containsPlan.setOperator(cop);
      containsPlan.addChild(attr.genPlan());
      if (exprs1 instanceof conformstoNode) {
	  containsPlan.addChild(exprs1.genPlan(attr));
      } else {
	  containsPlan.addChild(exprs1.genPlan());
      }
      plan.addChild(containsPlan);
    }
    if (exprs2 instanceof connectorNode) 
      plan.addChild(exprs2.genPlan(attr));
    else {
      QueryPlan containsPlan = new QueryPlan();
      ContainOp cop = new ContainOp();
      containsPlan.setOperator(cop);
      containsPlan.addChild(attr.genPlan());
      if (exprs2 instanceof conformstoNode) {
	  containsPlan.addChild(exprs2.genPlan(attr));
      } else {
	  containsPlan.addChild(exprs2.genPlan());
      }
      plan.addChild(containsPlan);
    }
    return plan;
  }
  exprNode exprs1;
  exprNode exprs2;
};

class andNode extends connectorNode {
  andNode(exprNode a, exprNode l, int line, int col){
    super(line,col);
    exprs1 = a;
    exprs2 = l;
  }
  QueryPlan genPlan() {
      identNode attr = new identNode("@doc",0,0);
      return genPlan(attr);
  }
  QueryPlan genPlan(exprNode attr) {
    QueryPlan plan = new QueryPlan();
    
    ANDOp operator = new ANDOp();
    plan.setOperator(operator);
    if (exprs1 instanceof connectorNode) 
      plan.addChild(exprs1.genPlan(attr));
    else {
      QueryPlan containsPlan = new QueryPlan();
      ContainOp cop = new ContainOp();
      containsPlan.setOperator(cop);
      containsPlan.addChild(attr.genPlan());
      if (exprs1 instanceof conformstoNode) {
	  containsPlan.addChild(exprs1.genPlan(attr));
      } else {
	  containsPlan.addChild(exprs1.genPlan());
      }
      plan.addChild(containsPlan);
    }
    if (exprs2 instanceof connectorNode) 
      plan.addChild(exprs2.genPlan(attr));
    else {
      QueryPlan containsPlan = new QueryPlan();
      ContainOp cop = new ContainOp();
      containsPlan.setOperator(cop);
      containsPlan.addChild(attr.genPlan());
      if (exprs2 instanceof conformstoNode) {
	  containsPlan.addChild(exprs2.genPlan(attr));
      } else {
	  containsPlan.addChild(exprs2.genPlan());
      }
      plan.addChild(containsPlan);
    }
    return plan;
  }
  exprNode exprs1;
  exprNode exprs2;
};

class exceptNode extends connectorNode {
  exceptNode(exprNode a, exprNode l, int line, int col){
    super(line,col);
    exprs1 = a;
    exprs2 = l;
  }
  QueryPlan genPlan() {
      identNode attr = new identNode("@doc",0,0);
      return genPlan(attr);
  }
  QueryPlan genPlan(exprNode attr) {
    QueryPlan plan = new QueryPlan();
    
    EXCEPTOp operator = new EXCEPTOp();
    plan.setOperator(operator);
    if (exprs1 instanceof connectorNode) 
      plan.addChild(exprs1.genPlan(attr));
    else {
      QueryPlan containsPlan = new QueryPlan();
      ContainOp cop = new ContainOp();
      containsPlan.setOperator(cop);
      containsPlan.addChild(attr.genPlan());
      if (exprs1 instanceof conformstoNode) {
	  containsPlan.addChild(exprs1.genPlan(attr));
      } else {
	  containsPlan.addChild(exprs1.genPlan());
      }
      plan.addChild(containsPlan);
    }
    if (exprs2 instanceof connectorNode) 
      plan.addChild(exprs2.genPlan(attr));
    else {
      QueryPlan containsPlan = new QueryPlan();
      ContainOp cop = new ContainOp();
      containsPlan.setOperator(cop);
      containsPlan.addChild(attr.genPlan());
      if (exprs2 instanceof conformstoNode) {
	  containsPlan.addChild(exprs2.genPlan(attr));
      } else {
	  containsPlan.addChild(exprs2.genPlan());
      }
      plan.addChild(containsPlan);
    }
    return plan;
  }
  exprNode exprs1;
  exprNode exprs2;
};

// abstract superclass; only subclasses are actually created
abstract class literalNode extends exprNode {
  literalNode(){super();};
  literalNode(int l,int c){super(l,c);};
  static nullLiteralNode NULL = new nullLiteralNode();
};

class nullLiteralNode extends literalNode {
  nullLiteralNode(){super();};
  boolean   isNull(){return true;};
  void Unparse(int indent){};
};




class nullExprNode extends exprNode {
	nullExprNode(){super();};
	boolean   isNull(){return true;};
	void Unparse(int indent){};
};
class nullQueryNode extends queryNode {
	nullQueryNode(){super();};
	boolean   isNull(){return true;};
	void Unparse(int indent){};
};

// abstract superclass; only subclasses are actually created
abstract class connectorNode extends exprNode {
	 connectorNode(){super();};
	 connectorNode(int l,int c){super(l,c);};
	static nullConnectorNode NULL = new nullConnectorNode();
};

class nullConnectorNode extends connectorNode {
	nullConnectorNode(){super();};
	boolean   isNull(){return true;};
	void Unparse(int indent){};
};




class identNode extends exprNode {
  identNode(String id, int line, int col){
    super(line,col);
    idval   = id;
    nullFlag = false;
  };

  identNode(boolean flag){
    super(0,0);
    idval   = "";
    nullFlag = flag;
  };

  boolean   isNull(){return nullFlag;}; // Is this node null?

  static identNode NULL = new identNode(true);

  void Unparse(int indent) {
    System.out.print(idval);
  }

    /*
  QueryPlan genPlan() {
    QueryPlan plan = new QueryPlan();
    Vector v = new Vector();
    v.addElement(IndexMgr.idxmgr);
    v.addElement(idval);
    v.addElement(new Boolean(true));
    
    IVLOp operator = new IVLOp(v);
    plan.setOperator(operator);
    return plan;
  }
    */

  QueryPlan genPlan() {
    QueryPlan plan = new QueryPlan();
    Vector v = new Vector();
    v.addElement(IndexMgr.idxmgr);
    v.addElement(idval);
    
    ElementOp operator = new ElementOp(v);
    plan.setOperator(operator);
    return plan;
  }
  String 	idval;
  boolean		nullFlag;
};

class numlitNode extends literalNode {
  numlitNode(double val, int line, int col){
    super(line,col);
    doubleval=val;
  }
  void Unparse(int indent) {
      System.out.print(doubleval);
  };

  double 	doubleval;
};

class strlitNode extends literalNode {
  strlitNode(String stringval, int line, int col){
    super(line,col);
    strval=stringval;
  }
  void Unparse(int indent) {
    System.out.print(strval);
  }
  QueryPlan genPlan() {
    QueryPlan plan = new QueryPlan();
    
    Vector v = new Vector();
    v.addElement(IndexMgr.idxmgr);
    v.addElement(strval);

    StringOp operator = new StringOp(v);
    plan.setOperator(operator);
    return plan;
  }

   String 	strval;
};



