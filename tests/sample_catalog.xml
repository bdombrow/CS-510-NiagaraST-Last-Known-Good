<?xml version="1.0" ?>
<!-- $Id: sample_catalog.xml,v 1.18 2003/09/13 03:48:40 vpapad Exp $ -->
<catalog>
  <operators>
  	<!-- Logical and physical operators, name to class mappings, and
  	     logical-to-physical mappings for unoptimized query plans. -->
    <logical name="dtdscan" 
      class="niagara.xmlql_parser.op_tree.dtdScanOp">
            <physical name="DTDThread" class="niagara.data_manager.DTDThread"/>
    </logical>
    <logical name="firehosescan" 
      class="niagara.xmlql_parser.op_tree.FirehoseScanOp">
            <physical name="StreamThread" class="niagara.data_manager.StreamThread"/>
    </logical>
    <logical name="filescan"
      class="niagara.xmlql_parser.op_tree.FileScanOp">
            <physical name="StreamThread" class="niagara.data_manager.StreamThread"/>      
    </logical>      
    <logical name="timer"
      class="niagara.logical.Timer">
      <physical name="TimerThread" class="niagara.data_manager.TimerThread"/>
    </logical>
    <logical name="prefix"
      class="niagara.logical.Prefix">
      <physical name="PhysicalPrefix" class="niagara.query_engine.PhysicalPrefix"/>
    </logical>
    <logical name="constant"
      class="niagara.xmlql_parser.op_tree.ConstantOp">
      <physical name="ConstantThread" class="niagara.data_manager.ConstantOpThread"/>
    </logical>
    <logical name="resource"
      class="niagara.xmlql_parser.op_tree.ResourceOp"/>
    <logical name="unnest"
      class="niagara.logical.Unnest">
      <physical name="PhysicalUnnest" class="niagara.query_engine.PhysicalUnnest"/>
    </logical>
    <logical name="select"
      class="niagara.logical.Select">
      <physical name="PhysicalSelect" class="niagara.query_engine.PhysicalSelectOperator"/>
    </logical>
    <logical name="join"
      class="niagara.xmlql_parser.op_tree.joinOp">
      <physical name="NestedLoopsJoin" class="niagara.query_engine.PhysicalNLJoinOperator"/>
      <physical name="HashJoin" class="niagara.query_engine.PhysicalHashJoinOperator"/>
    </logical>
    <logical name="construct"
      class="niagara.xmlql_parser.op_tree.constructOp">
      <physical name="PhysicalConstruct" class="niagara.query_engine.PhysicalConstructOperator"/>
    </logical>
    <logical name="avg"
      class="niagara.xmlql_parser.op_tree.averageOp">
      <physical name="PhysicalAverage" class="niagara.query_engine.PhysicalAverageOperator"/>
    </logical>
    <logical name="slidingAvg"
      class="niagara.xmlql_parser.op_tree.SlidingAverageOp">
      <physical name="PhysicalSlidingAverage" class="niagara.query_engine.PhysicalSlidingAverageOperator"/>
    </logical>
    <logical name="accumulate"
      class="niagara.xmlql_parser.op_tree.AccumulateOp">
      <physical name="PhysicalAccumulate" class="niagara.query_engine.PhysicalAccumulateOperator"/>
    </logical>
    <logical name="expression"
      class="niagara.xmlql_parser.op_tree.ExpressionOp">
      <physical name="PhysicalExpression" class="niagara.query_engine.PhysicalExpressionOperator"/>
    </logical>
    <logical name="sort"
      class="niagara.xmlql_parser.op_tree.SortOp">
      <physical name="PhysicalSort" class="niagara.query_engine.PhysicalSortOperator"/>
    </logical>
    <logical name="union"
      class="niagara.xmlql_parser.op_tree.UnionOp">
      <physical name="PhysicalUnion" class="niagara.query_engine.PhysicalUnionOperator"/>
    </logical>
    <logical name="display"
      class="niagara.xmlql_parser.op_tree.DisplayOp">
      <physical name="PhysicalDisplay" class="niagara.query_engine.PhysicalDisplayOperator"/>
    </logical>
    <logical name="send"
      class="niagara.xmlql_parser.op_tree.SendOp">
      <physical name="PhysicalSend" class="niagara.query_engine.PhysicalSendOperator"/>
    </logical>
    <logical name="receive"
      class="niagara.xmlql_parser.op_tree.ReceiveOp"/>
    <logical name="sum"
      class="niagara.xmlql_parser.op_tree.SumOp">
      <physical name="PhysicalSum" class="niagara.query_engine.PhysicalSumOperator"/>
    </logical>
    <logical name="slidingSum"
      class="niagara.xmlql_parser.op_tree.SlidingSumOp">
      <physical name="PhysicalSlidingSum" class="niagara.query_engine.PhysicalSlidingSumOperator"/>
    </logical>
     <logical name="max"
      class="niagara.xmlql_parser.op_tree.MaxOp">
      <physical name="PhysicalMax" class="niagara.query_engine.PhysicalMaxOperator"/>
    </logical>
    <logical name="slidingMax"
      class="niagara.xmlql_parser.op_tree.SlidingMaxOp">
      <physical name="PhysicalSlidingMax" class="niagara.query_engine.PhysicalSlidingMaxOperator"/>
    </logical>
    <logical name="count"
      class="niagara.xmlql_parser.op_tree.CountOp">
      <physical name="PhysicalCount" class="niagara.query_engine.PhysicalCountOperator"/>
    </logical>
    <logical name="slidingCount"
      class="niagara.xmlql_parser.op_tree.SlidingCountOp">
      <physical name="PhysicalSlidingCount" class="niagara.query_engine.PhysicalSlidingCountOperator"/>
    </logical>
    <logical name="dup"
      class="niagara.xmlql_parser.op_tree.dupOp">
      <physical name="PhysicalDup" class="niagara.query_engine.PhysicalDuplicateOperator"/>
    </logical>
    <logical name="incrmax"
      class="niagara.logical.IncrementalMax">
      <physical name="PhysicalIncrementalMax" class="niagara.query_engine.PhysicalIncrementalMax"/>
    </logical>
    <logical name="incravg"
      class="niagara.logical.IncrementalAverage">
      <physical name="PhysicalIncrementalAverage" class="niagara.query_engine.PhysicalIncrementalAverage"/>
    </logical>
    <logical name="partitionavg"
      class="niagara.logical.PartitionAvg">
      <physical name="PhysicalPartitionAvg" class="niagara.query_engine.PhysicalPartitionAvg"/>
    </logical>
    <logical name="partitionmax"
      class="niagara.logical.PartitionMax">
      <physical name="PhysicalPartitionMax" class="niagara.query_engine.PhysicalPartitionMax"/>
    </logical>
    <logical name="project" class="niagara.logical.Project"/>
    <logical name="noop"
      class="niagara.optimizer.NoOp">
      <physical name="PhysicalNoOp" class="niagara.optimizer.PhysicalNoOp"/>
    </logical>
    <logical name="punctuate"
       class="niagara.xmlql_parser.op_tree.punctuateOp">
       <physical name="PhysicalPunctuate"
                class="niagara.query_engine.PhysicalPunctuateOperator"/>
    </logical>
    <logical name="bucket"
       class="niagara.xmlql_parser.op_tree.BucketOp">
       <physical name="PhysicalBucket"
       		class="niagara.query_engine.PhysicalBucketOperator"/>
    </logical>
    <logical name="nest"
      class="niagara.logical.Nest">
      <physical name="PhysicalNest" class="niagara.query_engine.PhysicalNestOperator"/>
    </logical>
    <logical name="scanOp"
      class="niagara.xmlql_parser.op_tree.scanOp">
      <physical name="PhysicalScan" class="niagara.query_engine.PhysicalScanOperator"/>
    </logical>
    <physical name="PhysicalPredicatedUnnest"
    	class ="niagara.query_engine.PhysicalPredicatedUnnest"/>
    <physical name="PhysicalHead"
        class ="niagara.query_engine.PhysicalHeadOperator"/>
  </operators>

  <ruleset name="normal ruleset">
  	<rule type="simple" name="unnest to PhysicalUnnest">
  		<before><logical name="unnest"/></before>
 		<after><op name="PhysicalUnnest"/></after>
  	</rule>
  	<rule type="simple" name="construct to PhysicalConstruct">
  		<before><logical name="construct"/></before>
 		<after><op name="PhysicalConstruct"/></after>
  	</rule>
  	<rule type="simple" name="display to PhysicalDisplay">
  		<before><logical name="display"/></before>
 		<after><op name="PhysicalDisplay"/></after>
  	</rule>
	<rule type="simple" name="select to PhysicalSelect">
  		<before><logical name="select"/></before>
 		<after><op name="PhysicalSelect"/></after>
  	</rule> 
  	<rule type="simple" name="join to HashJoin" promise="5">
  		<before><logical name="join" condition="isEquiJoin"/></before>
 		<after><op name="HashJoin"/></after>
  	</rule> 
  	<rule type="simple" name="join to NestedLoopsJoin">
  		<before><logical name="join"/></before>
 		<after><op name="NestedLoopsJoin"/></after>
  	</rule>
  	<rule type="simple" name="constant to ConstantThread">
  		<before><logical name="constant"/></before>
 		<after><op name="ConstantThread"/></after>
  	</rule>
  	<rule type="simple" name="fhscan to StreamThread">
  		<before><logical name="firehosescan"/></before>
 		<after><op name="StreamThread"/></after>
  	</rule>
  	<rule type="simple" name="filescan to StreamThread">
  		<before><logical name="filescan"/></before>
 		<after><op name="StreamThread"/></after>
  	</rule>
  	<rule type="simple" name="firehosescan to StreamThread">
  		<before><logical name="firehosescan"/></before>
 		<after><op name="StreamThread"/></after>
  	</rule>
  	<rule type="simple" name="dtdscan to DTDThread">
  		<before><logical name="dtdscan"/></before>
 		<after><op name="DTDThread"/></after>
  	</rule>
  	<rule type="simple" name="avg to PhysicalAverage">
  		<before><logical name="avg"/></before>
 		<after><op name="PhysicalAverage"/></after>
  	</rule>
  	<rule type="simple" name="slidingAvg to PhysicalSlidingAverage">
  		<before><logical name="slidingAvg"/></before>
 		<after><op name="PhysicalSlidingAverage"/></after>
  	</rule>
  	<rule type="simple" name="count to PhysicalCount">
  		<before><logical name="count"/></before>
 		<after><op name="PhysicalCount"/></after>
  	</rule>
  	<rule type="simple" name="slidingCount to PhysicalSlidingCount">
  		<before><logical name="slidingCount"/></before>
 		<after><op name="PhysicalSlidingCount"/></after>
  	</rule>
  	<rule type="simple" name="sum to PhysicalSum">
  		<before><logical name="sum"/></before>
 		<after><op name="PhysicalSum"/></after>
  	</rule>
  	<rule type="simple" name="slidingSum to PhysicalSlidingSum">
  		<before><logical name="slidingSum"/></before>
 		<after><op name="PhysicalSlidingSum"/></after>
  	</rule>
  	<rule type="simple" name="max to PhysicalMax">
  		<before><logical name="max"/></before>
 		<after><op name="PhysicalMax"/></after>
  	</rule>
  	<rule type="simple" name="slidingMax to PhysicalSlidingMax">
  		<before><logical name="slidingMax"/></before>
 		<after><op name="PhysicalSlidingMax"/></after>
  	</rule>
  	<rule type="simple" name="incravg to PhysicalIncrementalAverage">
  		<before><logical name="incravg"/></before>
 		<after><op name="PhysicalIncrementalAverage"/></after>
  	</rule>
	<rule type="simple" name="partitionavg to PhysicalPartitionAvg">
		<before><logical name="partitionavg"/></before>
		<after><op name="PhysicalPartitionAvg"/></after>
	</rule>
  	<rule type="simple" name="incrmax to PhysicalIncrementalMax">
  		<before><logical name="incrmax"/></before>
 		<after><op name="PhysicalIncrementalMax"/></after>
  	</rule>
	<rule type="simple" name="partitionmax to PhysicalPartitionMax">
		<before><logical name="partitionmax"/></before>
		<after><op name="PhysicalPartitionMax"/></after>
	</rule>
  	<rule type="simple" name="sort to PhysicalSort">
  		<before><logical name="sort"/></before>
 		<after><op name="PhysicalSort"/></after>
  	</rule>
  	<rule type="simple" name="expression to PhysicalExpression">
  		<before><logical name="expression"/></before>
 		<after><op name="PhysicalExpression"/></after>
  	</rule>
  	<rule type="simple" name="dup to PhysicalDup">
  		<before><logical name="dup"/></before>
 		<after><op name="PhysicalDup"/></after>
  	</rule>
  	<rule type="simple" name="accumulate to PhysicalAccumulate">
  		<before><logical name="accumulate"/></before>
 		<after><op name="PhysicalAccumulate"/></after>
  	</rule>
  	<rule type="simple" name="prefix to PhysicalPrefix">
  		<before><logical name="prefix"/></before>
 		<after><op name="PhysicalPrefix"/></after>
  	</rule>
  	<rule type="simple" name="timer to TimerThread">
  		<before><logical name="timer"/></before>
 		<after><op name="TimerThread"/></after>
  	</rule>
  	
  	<rule type="simple" name="noop to PhysicalNoOp">
  		<before><logical name="noop"/></before>
 		<after><op name="PhysicalNoOp"/></after>
  	</rule>
	<rule type="simple" name="punctuate to PhysicalPunctuate">
		<before><logical name="punctuate"/></before>
		<after><op name="PhysicalPunctuate"/></after>
	</rule>
	<rule type="simple" name="bucket to PhysicalBucket">
		<before><logical name="bucket"/></before>
		<after><op name="PhysicalBucket"/></after>
	</rule>
	<rule type="simple" name="nest to PhysicalNest">
	        <before><logical name="nest"/></before>
		<after><op name="PhysicalNest"/></after>
        </rule>
	
  	<rule type="constructed" name="select-unnest to PhysicalPredicatedUnnest"
  		condition="isPushableInto" argument="unn">
  		<before>
  			<op name="sel" op="select">
  				<op name="unn" op="unnest">
	  				<leaf name="0"/>
  				</op>
  			</op>
  		</before>
  		<after>
  			<op op="PhysicalPredicatedUnnest" init="unn,sel">
	  				<leaf name="0"/>
	  		</op>
  		</after>
  	</rule>
  	
  	<!-- The duplicate-free join reordering rules from Pellenkoft et al., VLDB '97 -->
  	<rule type="custom" name="CommuteJoin" class="niagara.optimizer.rules.CommuteJoin" 
  	         mask="CommuteJoin,AssociateJoinRtoL,AssociateJoinLtoR,Exchange"/>
  	<rule type="custom" name="AssociateJoinRtoL" class="niagara.optimizer.rules.AssociateJoinRtoL"
  	         mask="AssociateJoinRtoL,AssociateJoinLtoR,Exchange"/>
  	<rule type="custom" name="AssociateJoinLtoR" class="niagara.optimizer.rules.AssociateJoinLtoR" 
  	         mask="AssociateJoinRtoL,AssociateJoinLtoR,Exchange"/>
  	<rule type="custom" name="Exchange" class="niagara.optimizer.rules.Exchange" 
  	         mask="AssociateJoinRtoL,AssociateJoinLtoR,Exchange"/>

  	<rule type="custom" name="SelectIntoJoin" class="niagara.optimizer.rules.SelectIntoJoin"/>
  	<rule type="custom" name="PushJoinPredicates" class="niagara.optimizer.rules.PushJoinPredicates"/>
  	<rule type="custom" name="SelectThruUnnest" class="niagara.optimizer.rules.SelectThruUnnest"/>
  	<rule type="simple" name="EmptySelectToNoOp">
  		<before><logical name="select" condition="isEmpty"/></before>
  		<after><op name="noop"/></after>
  	</rule>
  	<rule type="custom" name="UnionToPhysicalUnion" class="niagara.optimizer.rules.UnionToPhysicalUnion"/>
	
	<!-- To disable projection pushing, comment out this rule (and uncomment the next one) -->  	
  	<rule type="custom" name="PushProjection" class="niagara.optimizer.rules.PushProjection"/>
  	<!--
  	<rule type="simple" name="project to noop">
  		<before><logical name="project"/></before>
 		<after><op name="noop"/></after> 
  	</rule>
  	-->
  </ruleset>

  <ruleset name="consolidation ruleset">
  	<rule type="custom" name="commuteRL" class="niagara.optimizer.rules.CommuteRL"/>
  	<rule type="custom" name="associateRL" class="niagara.optimizer.rules.ConsolidatingAssociateJoinRtoL"/>
  	<rule type="custom" name="ConsolidateMeRule" class="niagara.optimizer.rules.ConsolidateMeRule"/>
  	<rule type="simple" name="resource to dtdscan">
  		<before><logical name="resource" condition="isLocallyResolvable"/></before>
 		<after><op name="dtdscan"/></after>
  	</rule>
	<!-- To disable projection pushing, comment out this rule (and uncomment the next one) -->  	
  	<rule type="custom" name="PushProjection" class="niagara.optimizer.rules.PushProjection"/>
  	<!--
  	<rule type="simple" name="project to noop">
  		<before><logical name="project"/></before>
 		<after><op name="noop"/></after> 
  	</rule>
  	-->
  </ruleset>
  
  	<!-- Cost Model -->
    <costmodel>
      <!-- Totally meaningless flat cost for all stream scan operators -->
      <stream_scan_cost value="100"/>
      <!-- Cost of parsing a document -->
      <document_parsing_cost value="1"/>
      <!-- Cost of reading a tuple -->
      <tuple_reading_cost value="0.01"/>
      <!-- Cost of unnesting per match -->
      <dom_unnesting_cost value="0.05"/>
      <!-- Cost of evaluating a predicate on one tuple -->
      <predicate_cost value="0.05"/>
      <!-- Cost of hashing one tuple -->
      <tuple_hashing_cost value="0.1"/>
      <!-- Cost of accumulating one tuple -->
      <tuple_accumulation_cost value="0.1"/>
      <!-- Cost of evaluating a used-defined expression over one tuple -->
      <expression_cost value="0.2"/>
      <!-- Cost of "constructing" one output tuple -->
      <tuple_construction_cost value="0.5"/>
      <!-- Cost of adding a field to a tuple -->
      <field_overhead value="0.05"/>
      <!-- Cost of opening an HTTP connection -->
      <open_connection_cost value="0.5"/>
      <!-- Cost of transmitting one tuple -->
      <tuple_transmission_cost value="0.1"/>
    </costmodel>

    <!-- Configuration parameters -->
    <config>
      <!-- Default fanout for unnest operations -->
      <unnest_fanout value="10"/>
      <!-- Cardinality restriction factor for groupby -->
      <restrictivity value="10"/>
    </config>
  
  	<!-- Resources: urn to url, or urn to server mappings -->
    <resource name="urn:niagara:comedies">
    <url location="http://king.cse.ogi.edu/xml/all_well.xml"/>
    <url location="http://king.cse.ogi.edu/xml/as_you.xml"/>
    <url location="http://king.cse.ogi.edu/xml/com_err.xml"/>
    <url location="http://king.cse.ogi.edu/xml/cymbelin.xml"/>
    <url location="http://king.cse.ogi.edu/xml/dream.xml"/>
    <url location="http://king.cse.ogi.edu/xml/lll.xml"/>
    <url location="http://king.cse.ogi.edu/xml/m_for_m.xml"/>
    <url location="http://king.cse.ogi.edu/xml/m_wives.xml"/>
    <url location="http://king.cse.ogi.edu/xml/merchant.xml"/>
    <url location="http://king.cse.ogi.edu/xml/much_ado.xml"/>
    <url location="http://king.cse.ogi.edu/xml/pericles.xml"/>
    <url location="http://king.cse.ogi.edu/xml/t_night.xml"/>
    <url location="http://king.cse.ogi.edu/xml/taming.xml"/>
    <url location="http://king.cse.ogi.edu/xml/tempest.xml"/>
    <url location="http://king.cse.ogi.edu/xml/troilus.xml"/>
    <url location="http://king.cse.ogi.edu/xml/win_tale.xml"/>
  </resource>

  <resource name="urn:niagara:tragedies">
    <resolver location="king.cse.ogi.edu:9090"/>
  </resource>
  
  <resource name="urn:niagara:numbers">
    <url location="http://king.cse.ogi.edu/xml/numbers.xml"/>
  </resource>

  <resource name="urn:niagara:morenumbers">
    <url location="http://king.cse.ogi.edu/xml/numbers.xml"/>
    <url location="http://king.cse.ogi.edu/xml/numbers.xml"/>
    <url location="http://king.cse.ogi.edu/xml/numbers.xml"/>
  </resource>

</catalog>
