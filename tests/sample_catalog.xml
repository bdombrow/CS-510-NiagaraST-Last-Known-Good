<?xml version="1.0" ?>
<!-- $Id: sample_catalog.xml,v 1.25 2006/12/05 22:46:36 tufte Exp $ -->
<catalog>
  <configuration>
    <!-- General configuration parameters -->
    <!-- Directory name where locally available data will be stored.
            Name is relative to the directory where the server starts up,
            the data manager will attempt to create it if it doesn't already exist. -->
    <param name="local data directory" value="data"/>
  </configuration>
  
  <operators>
  	<!-- Logical and physical operators, name to class mappings, and
  	     logical-to-physical mappings for unoptimized query plans. -->
    <logical name="dtdscan" 
      class="niagara.logical.DTDScan">
            <physical name="DTDThread" class="niagara.data_manager.DTDThread"/>
    </logical>
    <logical name="firehosescan" 
      class="niagara.logical.FirehoseScan">
            <physical name="StreamThread" class="niagara.data_manager.StreamThread"/>
    </logical>
    <logical name="filescan"
      class="niagara.logical.FileScan">
            <physical name="StreamThread" class="niagara.data_manager.StreamThread"/>      
    </logical>      
    <logical class="niagara.logical.DBScan" name="dbscan">
            <physical class="niagara.data_manager.DBThread" name="DBThread"/>      
    </logical>      
    <logical name="xmlscan" class="niagara.logical.XMLScan"/>
    <logical name="timer"
      class="niagara.logical.Timer">
      <physical name="TimerThread" class="niagara.data_manager.TimerThread"/>
    </logical>
    <logical name="load"
      class="niagara.logical.Load">
      <physical name="LoadThread" class="niagara.data_manager.LoadThread"/>
    </logical>
    <logical name="prefix"
      class="niagara.logical.Prefix">
      <physical name="PhysicalPrefix" class="niagara.physical.PhysicalPrefix"/>
    </logical>
    <logical name="constant"
      class="niagara.logical.ConstantScan">
      <physical name="ConstantThread" class="niagara.data_manager.ConstantOpThread"/>
    </logical>
    <logical name="resource"
      class="niagara.logical.Resource"/>
    <logical name="unnest"
      class="niagara.logical.Unnest">
      <physical name="PhysicalUnnest" class="niagara.physical.PhysicalUnnest"/>
    </logical>
    <logical name="select"
      class="niagara.logical.Select">
      <physical name="PhysicalSelect" class="niagara.physical.PhysicalSelect"/>
    </logical>
    <logical name="join"
      class="niagara.logical.Join">
      <physical name="NestedLoopsJoin" class="niagara.physical.PhysicalNLJoin"/>
      <physical name="HashJoin" class="niagara.physical.PhysicalHashJoin"/>
    </logical>
    <logical name="construct"
      class="niagara.logical.Construct">
      <physical name="PhysicalConstruct" class="niagara.physical.PhysicalConstruct"/>
    </logical>
    <logical name="avg"
      class="niagara.logical.Average">
      <physical name="PhysicalAverage" class="niagara.physical.PhysicalAverage"/>
    </logical>
    <logical name="accumulate"
      class="niagara.logical.Accumulate">
      <physical name="PhysicalAccumulate" class="niagara.physical.PhysicalAccumulate"/>
    </logical>
    <logical name="expression"
      class="niagara.logical.Expression">
      <physical name="PhysicalExpression" class="niagara.physical.PhysicalExpression"/>
    </logical>
    <logical name="sort"
      class="niagara.logical.Sort">
      <physical name="PhysicalSort" class="niagara.physical.PhysicalSort"/>
    </logical>
    <logical name="union"
      class="niagara.logical.Union">
      <physical name="PhysicalUnion" class="niagara.physical.PhysicalUnion"/>
    </logical>
    <logical name="display"
      class="niagara.logical.Display">
      <physical name="PhysicalDisplay" class="niagara.physical.PhysicalDisplay"/>
    </logical>
    <logical name="send"
      class="niagara.logical.Send">
      <physical name="PhysicalSend" class="niagara.physical.PhysicalSend"/>
    </logical>
    <logical name="receive"
      class="niagara.logical.Receive"/>
    <logical name="sum"
      class="niagara.logical.Sum">
      <physical name="PhysicalSum" class="niagara.physical.PhysicalSum"/>
    </logical>
    <logical name="min"
      class="niagara.logical.Min">
      <physical name="PhysicalMin" class="niagara.physical.PhysicalMin"/>
    </logical>
     <logical name="max"
      class="niagara.logical.Max">
      <physical name="PhysicalMax" class="niagara.physical.PhysicalMax"/>
    </logical>
    <logical name="count"
      class="niagara.logical.Count">
      <physical name="PhysicalCount" class="niagara.physical.PhysicalCount"/>
    </logical>
    <logical name="windowCount"
      class="niagara.logical.WindowCount">
      <physical name="PhysicalWindowCount" class="niagara.physical.PhysicalWindowCount"/>
    </logical>
    <logical name="windowMax"
      class="niagara.logical.WindowMax">
      <physical name="PhysicalWindowMax" class="niagara.physical.PhysicalWindowMax"/>
    </logical>
    <logical name="windowAverage"
      class="niagara.logical.WindowAverage">
      <physical name="PhysicalWindowAverage" class="niagara.physical.PhysicalWindowAverage"/>
    </logical>
    <logical name="dup"
      class="niagara.logical.Duplicate">
      <physical name="PhysicalDup" class="niagara.physical.PhysicalDuplicate"/>
    </logical>
    <logical name="incrmax"
      class="niagara.logical.IncrementalMax">
      <physical name="PhysicalIncrementalMax" class="niagara.physical.PhysicalIncrementalMax"/>
    </logical>
    <logical name="incravg"
      class="niagara.logical.IncrementalAverage">
      <physical name="PhysicalIncrementalAverage" class="niagara.physical.PhysicalIncrementalAverage"/>
    </logical>
    <logical name="partitionavg"
      class="niagara.logical.PartitionAvg">
      <physical name="PhysicalPartitionAvg" class="niagara.physical.PhysicalPartitionAvg"/>
    </logical>
    <logical name="partitionmax"
      class="niagara.logical.PartitionMax">
      <physical name="PhysicalPartitionMax" class="niagara.physical.PhysicalPartitionMax"/>
    </logical>
    <logical name="project" class="niagara.logical.Project"/>
    <logical name="noop"
      class="niagara.optimizer.NoOp">
      <physical name="PhysicalNoOp" class="niagara.optimizer.PhysicalNoOp"/>
    </logical>
    <logical name="punctuate"
       class="niagara.logical.Punctuate">
       <physical name="PhysicalPunctuate"
                class="niagara.physical.PhysicalPunctuate"/>
    </logical>
    <logical name="bucket"
       class="niagara.logical.Bucket">
       <physical name="PhysicalBucket"
       		class="niagara.physical.PhysicalBucket"/>
    </logical>
    <logical name="nest"
      class="niagara.logical.Nest">
      <physical name="PhysicalNest" class="niagara.physical.PhysicalNest"/>
    </logical>
    <logical name="store"
      class="niagara.logical.Store">
      <physical name="PhysicalStore" class="niagara.physical.PhysicalStore"/>
    </logical>
    <logical name="scanOp"
      class="niagara.logical.ScanOp">
      <physical name="PhysicalScan" class="niagara.physical.PhysicalScan"/>
    </logical>
    <physical name="PhysicalPredicatedUnnest"
    	class ="niagara.physical.PhysicalPredicatedUnnest"/>
    <physical name="PhysicalHead"
        class ="niagara.physical.PhysicalHead"/>
  </operators>

  <ruleset name="normal ruleset">
  	<rule type="simple" name="unnest to PhysicalUnnest">
  		<before><logical name="unnest"/></before>
 		<after><op name="PhysicalUnnest"/></after>
  	</rule>
  	<rule type="simple" name="construct to PhysicalConstruct">
  		<before><logical name="construct"/></before>
 		<after><op name="PhysicalConstruct"/></after>
  	</rule>
  	<rule type="simple" name="display to PhysicalDisplay">
  		<before><logical name="display"/></before>
 		<after><op name="PhysicalDisplay"/></after>
  	</rule>
  	<rule type="simple" name="select to PhysicalSelect">
  		<before><logical name="select"/></before>
 		<after><op name="PhysicalSelect"/></after>
  	</rule> 
  	<rule type="simple" name="join to HashJoin" promise="5">
  		<before><logical name="join" condition="isEquiJoin"/></before>
 		<after><op name="HashJoin"/></after>
  	</rule> 
  	<rule type="simple" name="join to NestedLoopsJoin">
  		<before><logical name="join"/></before>
 		<after><op name="NestedLoopsJoin"/></after>
  	</rule>
  	<rule type="simple" name="constant to ConstantThread">
  		<before><logical name="constant"/></before>
 		<after><op name="ConstantThread"/></after>
  	</rule>
  	<rule name="dbscan to DBThread" type="simple">
  		<before><logical name="dbscan"/></before>
 		<after><op name="DBThread"/></after>
  	</rule>
  	<rule type="simple" name="fhscan to StreamThread">
  		<before><logical name="firehosescan"/></before>
 		<after><op name="StreamThread"/></after>
  	</rule>
  	<rule type="simple" name="filescan to StreamThread">
  		<before><logical name="filescan"/></before>
 		<after><op name="StreamThread"/></after>
  	</rule>
  	<rule type="simple" name="firehosescan to StreamThread">
  		<before><logical name="firehosescan"/></before>
 		<after><op name="StreamThread"/></after>
  	</rule>
  	<rule type="simple" name="dtdscan to DTDThread">
  		<before><logical name="dtdscan"/></before>
 		<after><op name="DTDThread"/></after>
  	</rule>
  	<rule type="simple" name="avg to PhysicalAverage">
  		<before><logical name="avg"/></before>
 		<after><op name="PhysicalAverage"/></after>
  	</rule>
  	<rule type="simple" name="count to PhysicalCount">
  		<before><logical name="count"/></before>
 		<after><op name="PhysicalCount"/></after>
  	</rule>
	<rule type="simple" name="windowCount to PhysicalWindowCount">
		<before><logical name="windowCount"/></before>
		<after><op name="PhysicalWindowCount"/></after>
	</rule>
	<rule type="simple" name="windowMax to PhysicalWindowMax">
		<before><logical name="windowMax"/></before>
		<after><op name="PhysicalWindowMax"/></after>
	</rule>
	<rule type="simple" name="windowAverage to PhysicalWindowAverage">
		<before><logical name="windowAverage"/></before>
		<after><op name="PhysicalWindowAverage"/></after>
	</rule>
  	<rule type="simple" name="sum to PhysicalSum">
  		<before><logical name="sum"/></before>
 		<after><op name="PhysicalSum"/></after>
  	</rule>
	<rule type="simple" name="min to PhysicalMin">
		<before><logical name="min"/></before>
		<after><op name="PhysicalMin"/></after>
	</rule>
  	<rule type="simple" name="max to PhysicalMax">
  		<before><logical name="max"/></before>
 		<after><op name="PhysicalMax"/></after>
  	</rule>
  	<rule type="simple" name="incravg to PhysicalIncrementalAverage">
  		<before><logical name="incravg"/></before>
 		<after><op name="PhysicalIncrementalAverage"/></after>
  	</rule>
	<rule type="simple" name="partitionavg to PhysicalPartitionAvg">
		<before><logical name="partitionavg"/></before>
		<after><op name="PhysicalPartitionAvg"/></after>
	</rule>
  	<rule type="simple" name="incrmax to PhysicalIncrementalMax">
  		<before><logical name="incrmax"/></before>
 		<after><op name="PhysicalIncrementalMax"/></after>
  	</rule>
	<rule type="simple" name="partitionmax to PhysicalPartitionMax">
		<before><logical name="partitionmax"/></before>
		<after><op name="PhysicalPartitionMax"/></after>
	</rule>
  	<rule type="simple" name="sort to PhysicalSort">
  		<before><logical name="sort"/></before>
 		<after><op name="PhysicalSort"/></after>
  	</rule>
  	<rule type="simple" name="expression to PhysicalExpression">
  		<before><logical name="expression"/></before>
 		<after><op name="PhysicalExpression"/></after>
  	</rule>
  	<rule type="simple" name="dup to PhysicalDup">
  		<before><logical name="dup"/></before>
 		<after><op name="PhysicalDup"/></after>
  	</rule>
  	<rule type="simple" name="accumulate to PhysicalAccumulate">
  		<before><logical name="accumulate"/></before>
 		<after><op name="PhysicalAccumulate"/></after>
  	</rule>
  	<rule type="simple" name="prefix to PhysicalPrefix">
  		<before><logical name="prefix"/></before>
 		<after><op name="PhysicalPrefix"/></after>
  	</rule>
  	<rule type="simple" name="timer to TimerThread">
  		<before><logical name="timer"/></before>
 		<after><op name="TimerThread"/></after>
  	</rule>
  	
  	<rule type="simple" name="noop to PhysicalNoOp">
  		<before><logical name="noop"/></before>
 		<after><op name="PhysicalNoOp"/></after>
  	</rule>
	<rule type="simple" name="punctuate to PhysicalPunctuate">
		<before><logical name="punctuate"/></before>
		<after><op name="PhysicalPunctuate"/></after>
	</rule>
	<rule type="simple" name="bucket to PhysicalBucket">
		<before><logical name="bucket"/></before>
		<after><op name="PhysicalBucket"/></after>
	</rule>
	<rule type="simple" name="nest to PhysicalNest">
        <before><logical name="nest"/></before>
		<after><op name="PhysicalNest"/></after>
    </rule>
	<rule type="simple" name="store to PhysicalStore">
        <before><logical name="store"/></before>
		<after><op name="PhysicalStore"/></after>
    </rule>
	<rule type="simple" name="load to LoadThread">
        <before><logical name="load"/></before>
		<after><op name="LoadThread"/></after>
    </rule>
  	<rule type="constructed" name="select-unnest to PhysicalPredicatedUnnest"
  		condition="isPushableInto" argument="unn">
  		<before>
  			<op name="sel" op="select">
  				<op name="unn" op="unnest">
	  				<leaf name="0"/>
  				</op>
  			</op>
  		</before>
  		<after>
  			<op op="PhysicalPredicatedUnnest" init="unn,sel">
	  				<leaf name="0"/>
	  		</op>
  		</after>
  	</rule>
  	
  	<!-- The duplicate-free join reordering rules from Pellenkoft et al., VLDB '97 -->
  	<rule type="custom" name="CommuteJoin" class="niagara.optimizer.rules.CommuteJoin" 
  	         mask="CommuteJoin,AssociateJoinRtoL,AssociateJoinLtoR,Exchange"/>
  	<rule type="custom" name="AssociateJoinRtoL" class="niagara.optimizer.rules.AssociateJoinRtoL"
  	         mask="AssociateJoinRtoL,AssociateJoinLtoR,Exchange"/>
  	<rule type="custom" name="AssociateJoinLtoR" class="niagara.optimizer.rules.AssociateJoinLtoR" 
  	         mask="AssociateJoinRtoL,AssociateJoinLtoR,Exchange"/>
  	<rule type="custom" name="Exchange" class="niagara.optimizer.rules.Exchange" 
  	         mask="AssociateJoinRtoL,AssociateJoinLtoR,Exchange"/>

  	<rule type="custom" name="SelectIntoJoin" class="niagara.optimizer.rules.SelectIntoJoin"/>
  	<rule type="custom" name="PushJoinPredicates" class="niagara.optimizer.rules.PushJoinPredicates"/>
  	<rule type="custom" name="SelectThruUnnest" class="niagara.optimizer.rules.SelectThruUnnest"/>
  	<rule type="simple" name="EmptySelectToNoOp">
  		<before><logical name="select" condition="isEmpty"/></before>
  		<after><op name="noop"/></after>
  	</rule>
  	<rule type="custom" name="UnionToPhysicalUnion" class="niagara.optimizer.rules.UnionToPhysicalUnion"/>
	
	<!-- To disable projection pushing, comment out this rule (and uncomment the next one) -->  	
  	<rule type="custom" name="PushProjection" class="niagara.optimizer.rules.PushProjection"/>
  	<!--
  	<rule type="simple" name="project to noop">
  		<before><logical name="project"/></before>
 		<after><op name="noop"/></after> 
  	</rule>
  	-->
  	
  	<rule type="custom" name="UnfoldXMLScan" class="niagara.optimizer.rules.UnfoldXMLScan"/>
  </ruleset>

  <ruleset name="consolidation ruleset">
  	<rule type="custom" name="commuteRL" class="niagara.optimizer.rules.CommuteRL"/>
  	<rule type="custom" name="associateRL" class="niagara.optimizer.rules.ConsolidatingAssociateJoinRtoL"/>
  	<rule type="custom" name="ConsolidateMeRule" class="niagara.optimizer.rules.ConsolidateMeRule"/>
  	<rule type="simple" name="resource to dtdscan">
  		<before><logical name="resource" condition="isLocallyResolvable"/></before>
 		<after><op name="dtdscan"/></after>
  	</rule>
	<!-- To disable projection pushing, comment out this rule (and uncomment the next one) -->  	
  	<rule type="custom" name="PushProjection" class="niagara.optimizer.rules.PushProjection"/>
  	<!--
  	<rule type="simple" name="project to noop">
  		<before><logical name="project"/></before>
 		<after><op name="noop"/></after> 
  	</rule>
  	-->
  </ruleset>
  
  	<!-- Cost Model -->
    <costmodel>
      <!-- Totally meaningless flat cost for all stream scan operators -->
      <stream_scan_cost value="100"/>
      <!-- Cost of parsing a document -->
      <document_parsing_cost value="1"/>
      <!-- Cost of reading a tuple -->
      <tuple_reading_cost value="0.01"/>
      <!-- Cost of storing a document -->
      <document_storage_cost value="100"/>
      <!-- Cost of unnesting per match -->
      <dom_unnesting_cost value="0.05"/>
      <!-- Cost of evaluating a predicate on one tuple -->
      <predicate_cost value="0.05"/>
      <!-- Cost of hashing one tuple -->
      <tuple_hashing_cost value="0.1"/>
      <!-- Cost of accumulating one tuple -->
      <tuple_accumulation_cost value="0.1"/>
      <!-- Cost of evaluating a used-defined expression over one tuple -->
      <expression_cost value="0.2"/>
      <!-- Cost of "constructing" one output tuple -->
      <tuple_construction_cost value="0.5"/>
      <!-- Cost of adding a field to a tuple -->
      <field_overhead value="0.05"/>
      <!-- Cost of opening an HTTP connection -->
      <open_connection_cost value="0.5"/>
      <!-- Cost of transmitting one tuple -->
      <tuple_transmission_cost value="0.1"/>
    </costmodel>

    <!-- Configuration parameters -->
    <config>
      <!-- Default fanout for unnest operations -->
      <unnest_fanout value="10"/>
      <!-- Cardinality restriction factor for groupby -->
      <restrictivity value="10"/>
    </config>
  
<!-- The resource list contains mappings from resources (URNs) to
        local files, URLs, or resolver addresses (servers that can resolve
        the URN). This element is reconstructed on every server shutdown,
        manual edits while the server is running will be lost! -->
<resources/>
</catalog>
