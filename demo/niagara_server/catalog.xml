<?xml version="1.0"?>
<catalog>
  <streams>
    <stream delay="-1" filename="/stash/datalab/datastreams-student/streamdata/auctions10k.xml" isStream="yes" name="auctions">
      <var name="id" type="int"/>
      <var name="reserve" type="int"/>
      <var name="sellerid" type="int"/>
      <var name="category" type="int"/>
      <var name="expires" type="int"/>
    </stream>
    <stream delay="-1" filename="auctions1MB.xml" isStream="yes" name="auctionslarge">
      <var name="id" type="int"/>
      <var name="reserve" type="int"/>
      <var name="sellerid" type="int"/>
      <var name="category" type="int"/>
      <var name="expires" type="int"/>
    </stream>
    <stream delay="-1" filename="/stash/datalab/datastreams-student/streamdata/bids10k.xml" isStream="yes" name="bids">
      <var name="auctionid" type="int"/>
      <var name="time" type="int"/>
      <var name="bidderid" type="int"/>
      <var name="amt" type="double"/>
    </stream>
    <stream delay="-1" filename="bids1MB.xml" isStream="yes" name="bidslarge">
      <var name="auctionid" type="int"/>
      <var name="time" type="int"/>
      <var name="bidderid" type="int"/>
      <var name="amt" type="double"/>
    </stream>
  </streams>

  <configuration>
    <!-- General configuration parameters -->
    <!-- Directory name where locally available data will be stored.
            Name is relative to the directory where the server starts up,
            the data manager will attempt to create it if it doesn't already exist. -->
    <param name="local data directory" value="data"/>
    <!-- Directory name whose static files will be made available PUBLICLY
         through the HTTP server. Name is relative to the directory where
         the server starts up. -->
    <param name="web directory" value="public_html"/>

    <param name="query threads" value="5"/>
    <param name="operator threads" value="30"/>
    <param name="sendStr" value="false"/>
    <param name="update catalog file on shutdown" value="true"/>
  </configuration>
  
  <operators>
  	<!-- Logical and physical operators, name to class mappings, and
  	     logical-to-physical mappings for unoptimized query plans. -->
  	<logical class="niagara.logical.Rename" name="rename">
            <physical class="niagara.physical.PhysicalRename" name="PhysicalRename"/>
  	</logical>
    <logical class="niagara.logical.DTDScan" name="dtdscan">
            <physical class="niagara.data_manager.DTDThread" name="DTDThread"/>
    </logical>
    <logical class="niagara.logical.FirehoseScan" name="firehosescan">
            <physical class="niagara.data_manager.StreamThread" name="StreamThread"/>
    </logical>
    <logical class="niagara.logical.FileScan" name="filescan">
            <physical class="niagara.data_manager.StreamThread" name="StreamThread"/>      
    </logical>
    <logical class="niagara.logical.DBScan" name="dbscan">
            <physical class="niagara.data_manager.DBThread" name="DBThread"/>      
    </logical>    
    <logical class="niagara.logical.DBScanImpute" name="dbscanimpute">
            <physical class="niagara.data_manager.DBThreadImpute" name="DBThreadImpute"/>      
    </logical>         
    <logical class="niagara.logical.XMLScan" name="xmlscan"/>
    <logical class="niagara.logical.Timer" name="timer">
      <physical class="niagara.data_manager.TimerThread" name="TimerThread"/>
    </logical>
    <logical class="niagara.logical.Load" name="load">
      <physical class="niagara.data_manager.LoadThread" name="LoadThread"/>
    </logical>
    <logical class="niagara.logical.Prefix" name="prefix">
      <physical class="niagara.physical.PhysicalPrefix" name="PhysicalPrefix"/>
    </logical>
    <logical class="niagara.logical.ConstantScan" name="constant">
      <physical class="niagara.data_manager.ConstantOpThread" name="ConstantThread"/>
    </logical>
    <logical class="niagara.logical.ShowTunables" name="showTunables">
      <physical class="niagara.data_manager.ShowTunablesThread" name="ShowTunablesThread"/>
    </logical>
    <logical class="niagara.logical.CollectInstrumentation" name="collectInstrumentation">
      <physical class="niagara.data_manager.CollectInstrumentationThread" name="CollectInstrumentationThread"/>
    </logical>
    <logical class="niagara.logical.Resource" name="resource"/>
    <logical class="niagara.logical.Unnest" name="unnest">
      <physical class="niagara.physical.PhysicalUnnest" name="PhysicalUnnest"/>
    </logical>
    <logical class="niagara.logical.Select" name="select">
      <physical class="niagara.physical.PhysicalSelect" name="PhysicalSelect"/>
    </logical>
    <logical class="niagara.logical.Magic" name="magic">
      <physical class="niagara.physical.PhysicalMagic" name="PhysicalMagic"/>
    </logical>
    <logical class="niagara.logical.Join" name="join">
      <physical class="niagara.physical.PhysicalNLJoin" name="NestedLoopsJoin"/>
      <physical class="niagara.physical.PhysicalHashJoin" name="HashJoin"/>
    </logical>
    <logical class="niagara.logical.WindowJoin" name="windowJoin">
      <physical class="niagara.physical.PhysicalWindowJoin" name="WindowJoin"/>
    </logical>
    <logical class="niagara.logical.Construct" name="construct">
      <physical class="niagara.physical.PhysicalConstruct" name="PhysicalConstruct"/>
    </logical>
    <logical class="niagara.logical.Average" name="avg">
      <physical class="niagara.physical.PhysicalAverage" name="PhysicalAverage"/>
    </logical>
    <logical class="niagara.logical.Accumulate" name="accumulate">
      <physical class="niagara.physical.PhysicalAccumulate" name="PhysicalAccumulate"/>
    </logical>
    <logical class="niagara.logical.Expression" name="expression">
      <physical class="niagara.physical.PhysicalExpression" name="PhysicalExpression"/>
    </logical>
    <logical class="niagara.logical.Sort" name="sort">
      <physical class="niagara.physical.PhysicalSort" name="PhysicalSort"/>
    </logical>
    <logical class="niagara.logical.Union" name="union">
      <physical class="niagara.physical.PhysicalUnion" name="PhysicalUnion"/>
    </logical>
    <logical class="niagara.logical.Display" name="display">
      <physical class="niagara.physical.PhysicalDisplay" name="PhysicalDisplay"/>
    </logical>
    <logical class="niagara.logical.Send" name="send">
      <physical class="niagara.physical.PhysicalSend" name="PhysicalSend"/>
    </logical>
    <logical class="niagara.logical.Receive" name="receive"/>
    <logical class="niagara.logical.Sum" name="sum">
      <physical class="niagara.physical.PhysicalSum" name="PhysicalSum"/>
    </logical>
    <logical class="niagara.logical.Min" name="min">
      <physical class="niagara.physical.PhysicalMin" name="PhysicalMin"/>
    </logical>
     <logical class="niagara.logical.Max" name="max">
      <physical class="niagara.physical.PhysicalMax" name="PhysicalMax"/>
    </logical>
    <logical class="niagara.logical.Count" name="count">
      <physical class="niagara.physical.PhysicalCount" name="PhysicalCount"/>
    </logical>
    <logical class="niagara.logical.WindowCount" name="windowCount">
      <physical class="niagara.physical.PhysicalWindowCount" name="PhysicalWindowCount"/>
    </logical>
    <logical class="niagara.logical.WindowMax" name="windowMax">
      <physical class="niagara.physical.PhysicalWindowMax" name="PhysicalWindowMax"/>
    </logical>
    <logical class="niagara.logical.WindowAverage" name="windowAverage">
      <physical class="niagara.physical.PhysicalWindowAverage" name="PhysicalWindowAverage"/>
    </logical>
    <logical class="niagara.logical.Duplicate" name="dup">
      <physical class="niagara.physical.PhysicalDuplicate" name="PhysicalDup"/>
    </logical>
    <logical class="niagara.logical.IncrementalMax" name="incrmax">
      <physical class="niagara.physical.PhysicalIncrementalMax" name="PhysicalIncrementalMax"/>
    </logical>
    <logical class="niagara.logical.IncrementalAverage" name="incravg">
      <physical class="niagara.physical.PhysicalIncrementalAverage" name="PhysicalIncrementalAverage"/>
    </logical>
    <logical class="niagara.logical.PartitionAvg" name="partitionavg">
      <physical class="niagara.physical.PhysicalPartitionAvg" name="PhysicalPartitionAvg"/>
    </logical>
    <logical class="niagara.logical.PartitionMax" name="partitionmax">
      <physical class="niagara.physical.PhysicalPartitionMax" name="PhysicalPartitionMax"/>
    </logical>
    <logical class="niagara.logical.Project" name="project"/>
    <logical class="niagara.optimizer.NoOp" name="noop">
      <physical class="niagara.optimizer.PhysicalNoOp" name="PhysicalNoOp"/>
    </logical>
    <logical class="niagara.logical.Punctuate" name="punctuate">
       <physical class="niagara.physical.PhysicalPunctuate" name="PhysicalPunctuate"/>
    </logical>
    <logical class="niagara.logical.PunctQC" name="punctqc">
       <physical class="niagara.physical.PhysicalPunctQC" name="PhysicalPunctQC"/>
    </logical>
    <logical class="niagara.logical.Impute" name="impute">
       <physical class="niagara.physical.PhysicalImpute" name="PhysicalImpute"/>
    </logical>    
    <logical class="niagara.logical.Bucket" name="bucket">
       <physical class="niagara.physical.PhysicalBucket" name="PhysicalBucket"/>
    </logical>
    <logical class="niagara.logical.Nest" name="nest">
      <physical class="niagara.physical.PhysicalNest" name="PhysicalNest"/>
    </logical>
    <logical class="niagara.logical.Store" name="store">
      <physical class="niagara.physical.PhysicalStore" name="PhysicalStore"/>
    </logical>
    <logical class="niagara.logical.ScanOp" name="scanOp">
      <physical class="niagara.physical.PhysicalScan" name="PhysicalScan"/>
    </logical>
    <physical class="niagara.physical.PhysicalPredicatedUnnest" name="PhysicalPredicatedUnnest"/>
    <physical class="niagara.physical.PhysicalHead" name="PhysicalHead"/>
    <logical class="niagara.logical.Present" name="present">
      <physical class="niagara.physical.PhysicalPresent" name="PhysicalPresent"/>
    </logical>

  </operators>

  <ruleset name="normal ruleset">
  	<rule name="unnest to PhysicalUnnest" type="simple">
  		<before><logical name="unnest"/></before>
 		<after><op name="PhysicalUnnest"/></after>
  	</rule>
  	<rule name="construct to PhysicalConstruct" type="simple">
  		<before><logical name="construct"/></before>
 		<after><op name="PhysicalConstruct"/></after>
  	</rule>
  	<rule name="display to PhysicalDisplay" type="simple">
  		<before><logical name="display"/></before>
 		<after><op name="PhysicalDisplay"/></after>
  	</rule>
  	<rule name="select to PhysicalSelect" type="simple">
  		<before><logical name="select"/></before>
 		<after><op name="PhysicalSelect"/></after>
  	</rule> 
  	<rule name="rename to PhysicalRename" type="simple">
  		<before><logical name="rename"/></before>
 		<after><op name="PhysicalRename"/></after>
  	</rule>
 	<rule name="select to PhysicalMagic" type="simple">
  		<before><logical name="magic"/></before>
 		<after><op name="PhysicalMagic"/></after>
  	</rule> 
  	<rule name="join to HashJoin" promise="5" type="simple">
  		<before><logical condition="isEquiJoin" name="join"/></before>
 		<after><op name="HashJoin"/></after>
  	</rule> 
  	<rule name="join to NestedLoopsJoin" type="simple">
  		<before><logical name="join"/></before>
 		<after><op name="NestedLoopsJoin"/></after>
  	</rule>
	<rule name="windowJoin to WindowJoin" type="simple">
		<before><logical name="windowJoin"/></before>
		<after><op name="WindowJoin"/></after>
	</rule>
  	<rule name="constant to ConstantThread" type="simple">
  		<before><logical name="constant"/></before>
 		<after><op name="ConstantThread"/></after>
  	</rule>
  	<rule name="dbscan to DBThread" type="simple">
  		<before><logical name="dbscan"/></before>
 		<after><op name="DBThread"/></after>
  	</rule> 
  	<rule name="dbscanimpute to DBThreadImpute" type="simple">
  		<before><logical name="dbscanimpute"/></before>
 		<after><op name="DBThreadImpute"/></after>
  	</rule> 	
       <rule name="showTunables to ShowTunablesThread" type="simple">
               <before><logical name="showTunables"/></before>
               <after><op name="ShowTunablesThread"/></after>
       </rule>
       <rule name="collectInstrumentation to CollectInstrumentationThread" type="simple">
               <before><logical name="collectInstrumentation"/></before>
               <after><op name="CollectInstrumentationThread"/></after>
       </rule>
  	<rule name="fhscan to StreamThread" type="simple">
  		<before><logical name="firehosescan"/></before>
 		<after><op name="StreamThread"/></after>
  	</rule>
  	<rule name="filescan to StreamThread" type="simple">
  		<before><logical name="filescan"/></before>
 		<after><op name="StreamThread"/></after>
  	</rule>
  	<rule name="firehosescan to StreamThread" type="simple">
  		<before><logical name="firehosescan"/></before>
 		<after><op name="StreamThread"/></after>
  	</rule>
  	<rule name="dtdscan to DTDThread" type="simple">
  		<before><logical name="dtdscan"/></before>
 		<after><op name="DTDThread"/></after>
  	</rule>
  	<rule name="avg to PhysicalAverage" type="simple">
  		<before><logical name="avg"/></before>
 		<after><op name="PhysicalAverage"/></after>
  	</rule>
  	<rule name="count to PhysicalCount" type="simple">
  		<before><logical name="count"/></before>
 		<after><op name="PhysicalCount"/></after>
  	</rule>
	<rule name="windowCount to PhysicalWindowCount" type="simple">
		<before><logical name="windowCount"/></before>
		<after><op name="PhysicalWindowCount"/></after>
	</rule>
	<rule name="windowMax to PhysicalWindowMax" type="simple">
		<before><logical name="windowMax"/></before>
		<after><op name="PhysicalWindowMax"/></after>
	</rule>
	<rule name="windowAverage to PhysicalWindowAverage" type="simple">
		<before><logical name="windowAverage"/></before>
		<after><op name="PhysicalWindowAverage"/></after>
	</rule>
  	<rule name="sum to PhysicalSum" type="simple">
  		<before><logical name="sum"/></before>
 		<after><op name="PhysicalSum"/></after>
  	</rule>
	<rule name="min to PhysicalMin" type="simple">
		<before><logical name="min"/></before>
		<after><op name="PhysicalMin"/></after>
	</rule>
  	<rule name="max to PhysicalMax" type="simple">
  		<before><logical name="max"/></before>
 		<after><op name="PhysicalMax"/></after>
  	</rule>
  	<rule name="incravg to PhysicalIncrementalAverage" type="simple">
  		<before><logical name="incravg"/></before>
 		<after><op name="PhysicalIncrementalAverage"/></after>
  	</rule>
	<rule name="partitionavg to PhysicalPartitionAvg" type="simple">
		<before><logical name="partitionavg"/></before>
		<after><op name="PhysicalPartitionAvg"/></after>
	</rule>
  	<rule name="incrmax to PhysicalIncrementalMax" type="simple">
  		<before><logical name="incrmax"/></before>
 		<after><op name="PhysicalIncrementalMax"/></after>
  	</rule>
	<rule name="partitionmax to PhysicalPartitionMax" type="simple">
		<before><logical name="partitionmax"/></before>
		<after><op name="PhysicalPartitionMax"/></after>
	</rule>
  	<rule name="sort to PhysicalSort" type="simple">
  		<before><logical name="sort"/></before>
 		<after><op name="PhysicalSort"/></after>
  	</rule>
  	<rule name="expression to PhysicalExpression" type="simple">
  		<before><logical name="expression"/></before>
 		<after><op name="PhysicalExpression"/></after>
  	</rule>
  	<rule name="dup to PhysicalDup" type="simple">
  		<before><logical name="dup"/></before>
 		<after><op name="PhysicalDup"/></after>
  	</rule>
  	<rule name="accumulate to PhysicalAccumulate" type="simple">
  		<before><logical name="accumulate"/></before>
 		<after><op name="PhysicalAccumulate"/></after>
  	</rule>
  	<rule name="prefix to PhysicalPrefix" type="simple">
  		<before><logical name="prefix"/></before>
 		<after><op name="PhysicalPrefix"/></after>
  	</rule>
  	<rule name="timer to TimerThread" type="simple">
  		<before><logical name="timer"/></before>
 		<after><op name="TimerThread"/></after>
  	</rule>
  	
  	<rule name="noop to PhysicalNoOp" type="simple">
  		<before><logical name="noop"/></before>
 		<after><op name="PhysicalNoOp"/></after>
  	</rule>
	<rule name="punctuate to PhysicalPunctuate" type="simple">
		<before><logical name="punctuate"/></before>
		<after><op name="PhysicalPunctuate"/></after>
	</rule>
	<rule name="bucket to PhysicalBucket" type="simple">
		<before><logical name="bucket"/></before>
		<after><op name="PhysicalBucket"/></after>
	</rule>
	<rule name="nest to PhysicalNest" type="simple">
        <before><logical name="nest"/></before>
		<after><op name="PhysicalNest"/></after>
    </rule>
	<rule name="store to PhysicalStore" type="simple">
        <before><logical name="store"/></before>
		<after><op name="PhysicalStore"/></after>
    </rule>
	<rule name="load to LoadThread" type="simple">
        <before><logical name="load"/></before>
		<after><op name="LoadThread"/></after>
    </rule>
  <rule name="present to PhysicalPresent" type="simple">
  		<before><logical name="present"/></before>
 		<after><op name="PhysicalPresent"/></after>
  	</rule> 
	<rule name="punctqc to PhysicalPunctQC" type="simple">
		<before><logical name="punctqc"/></before>
		<after><op name="PhysicalPunctQC"/></after>
	</rule>
	<rule name="impute to PhysicalImpute" type="simple">
		<before><logical name="impute"/></before>
		<after><op name="PhysicalImpute"/></after>
	</rule>	
	<!--
  	<rule argument="unn" condition="isPushableInto" name="select-unnest to PhysicalPredicatedUnnest" type="constructed">
  		<before>
  			<op name="sel" op="select">
  				<op name="unn" op="unnest">
	  				<leaf name="0"/>
  				</op>
  			</op>
  		</before>
  		<after>
  			<op init="unn,sel" op="PhysicalPredicatedUnnest">
	  				<leaf name="0"/>
	  		</op>
  		</after>
  	</rule>
  	-->
  	
  	<!-- The duplicate-free join reordering rules from Pellenkoft et al., VLDB '97 -->
  	<rule class="niagara.optimizer.rules.CommuteJoin" mask="CommuteJoin,AssociateJoinRtoL,AssociateJoinLtoR,Exchange" name="CommuteJoin" type="custom"/>
  	<rule class="niagara.optimizer.rules.AssociateJoinRtoL" mask="AssociateJoinRtoL,AssociateJoinLtoR,Exchange" name="AssociateJoinRtoL" type="custom"/>
  	<rule class="niagara.optimizer.rules.AssociateJoinLtoR" mask="AssociateJoinRtoL,AssociateJoinLtoR,Exchange" name="AssociateJoinLtoR" type="custom"/>
  	<rule class="niagara.optimizer.rules.Exchange" mask="AssociateJoinRtoL,AssociateJoinLtoR,Exchange" name="Exchange" type="custom"/>

  	<rule class="niagara.optimizer.rules.SelectIntoJoin" name="SelectIntoJoin" type="custom"/>
  	<rule class="niagara.optimizer.rules.PushJoinPredicates" name="PushJoinPredicates" type="custom"/>
  	<rule class="niagara.optimizer.rules.SelectThruUnnest" name="SelectThruUnnest" type="custom"/> 
  	<rule name="EmptySelectToNoOp" type="simple">
  		<before><logical condition="isEmpty" name="select"/></before>
  		<after><op name="noop"/></after>
  	</rule>
  	<rule class="niagara.optimizer.rules.UnionToPhysicalUnion" name="UnionToPhysicalUnion" type="custom"/>
	
	<!-- To disable projection pushing, comment out this rule (and uncomment the next one) -->  	
  	<rule class="niagara.optimizer.rules.PushProjection" name="PushProjection" type="custom"/>
  	<!--
  	<rule type="simple" name="project to noop">
  		<before><logical name="project"/></before>
 		<after><op name="noop"/></after> 
  	</rule>
  	-->
  	
  	<rule class="niagara.optimizer.rules.UnfoldXMLScan" name="UnfoldXMLScan" type="custom"/>
  </ruleset>

  <ruleset name="consolidation ruleset">
  	<rule class="niagara.optimizer.rules.CommuteRL" name="commuteRL" type="custom"/>
  	<rule class="niagara.optimizer.rules.ConsolidatingAssociateJoinRtoL" name="associateRL" type="custom"/>
  	<rule class="niagara.optimizer.rules.ConsolidateMeRule" name="ConsolidateMeRule" type="custom"/>
  	<rule name="resource to dtdscan" type="simple">
  		<before><logical condition="isLocallyResolvable" name="resource"/></before>
 		<after><op name="dtdscan"/></after>
  	</rule>
	<!-- To disable projection pushing, comment out this rule (and uncomment the next one) -->  	
  	<rule class="niagara.optimizer.rules.PushProjection" name="PushProjection" type="custom"/>
  	<!--
  	<rule type="simple" name="project to noop">
  		<before><logical name="project"/></before>
 		<after><op name="noop"/></after> 
  	</rule>
  	-->
  </ruleset>
  
  	<!-- Cost Model -->
    <costmodel>
      <!-- Totally meaningless flat cost for all stream scan operators -->
      <stream_scan_cost value="100"/>
      <!-- Cost of parsing a document -->
      <document_parsing_cost value="1"/>
      <!-- Cost of reading a tuple -->
      <tuple_reading_cost value="0.01"/>
      <!-- Cost of storing a document -->
      <document_storage_cost value="100"/>
      <!-- Cost of unnesting per match -->
      <dom_unnesting_cost value="0.05"/>
      <!-- Cost of evaluating a predicate on one tuple -->
      <predicate_cost value="0.05"/>
      <!-- Cost of hashing one tuple -->
      <tuple_hashing_cost value="0.1"/>
      <!-- Cost of accumulating one tuple -->
      <tuple_accumulation_cost value="0.1"/>
      <!-- Cost of evaluating a used-defined expression over one tuple -->
      <expression_cost value="0.2"/>
      <!-- Cost of "constructing" one output tuple -->
      <tuple_construction_cost value="0.5"/>
      <!-- Cost of adding a field to a tuple -->
      <field_overhead value="0.05"/>
      <!-- Cost of opening an HTTP connection -->
      <open_connection_cost value="0.5"/>
      <!-- Cost of transmitting one tuple -->
      <tuple_transmission_cost value="0.1"/>
    </costmodel>

    <!-- Configuration parameters -->
    <config>
      <!-- Default fanout for unnest operations -->
      <unnest_fanout value="10"/>
      <!-- Cardinality restriction factor for groupby -->
      <restrictivity value="10"/>
    </config>
  
<!-- The resource list contains mappings from resources (URNs) to
        local files, URLs, or resolver addresses (servers that can resolve
        the URN). This element is reconstructed on every server shutdown,
        manual edits while the server is running will be lost! -->
<resources>
</resources>
</catalog>