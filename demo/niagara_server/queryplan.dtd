<!-- DTD for query plans -->

<!ENTITY  NLJoin 'niagara.query_engine.PhysicalNLJoinOperator' >
<!ENTITY  HashJoin 'niagara.query_engine.PhysicalHashJoinOperator' >

<!-- 
     Plan is a dummy node, representing the output of a query plan.
     top is a ref to the topmost operator, usually a construct.
-->
<!ENTITY % PositionAttributes "x CDATA #IMPLIED
          y CDATA #IMPLIED">

<!ELEMENT plan     (scan | select | join | avg | construct | 
                    dtdscan | constant | resource | firehosescan | accumulate | 
                    expression | send | display | topn |
		    sort | dup | union)+>

<!ATTLIST plan top IDREF        #REQUIRED
          %PositionAttributes;>

<!-- 
     For all operators, an "id" attribute is required, so that other 
     operators may reference them. Also for logical operators with 
     multiple physical implementations available, a "physical" attribute
     may be attached, specifying the class name of the physical operator.
-->
<!ENTITY % StandardAttributes "id ID   #REQUIRED
         physical  CDATA               #IMPLIED
	 input     IDREF               #REQUIRED
         location  CDATA               #IMPLIED                        
	 %PositionAttributes;">

<!-- 
     type : Whether we want the element itself, its content, or its tag name
     root:  Where is the regular expression rooted. Default: scan's input
     regexp: The XML-QL regular expression
-->

<!ELEMENT scan     EMPTY>
<!ATTLIST scan 

	  type	   (tag|element|content) "element"
	  root	   CDATA                 ""
	  regexp   CDATA               #REQUIRED
	  %StandardAttributes;>

<!ELEMENT sort     EMPTY>
<!ATTLIST sort 

	  order	   (descending|ascending) "descending"
	  comparison (alphabetic|numeric) "alphabetic"
	  sort_by  CDATA               #REQUIRED
	  %StandardAttributes;>

<!ELEMENT expression     EMPTY>
<!ATTLIST expression 

	  class   CDATA               #REQUIRED
	  expression CDATA	      ""
	  %StandardAttributes;>


<!ELEMENT avg     EMPTY>
<!ATTLIST avg 
	  groupby  CDATA	       #REQUIRED
	  avgattr  CDATA	       #REQUIRED
	  %StandardAttributes;>

<!ELEMENT sum     EMPTY>
<!ATTLIST sum 
	  groupby  CDATA	       #REQUIRED
	  sumattr  CDATA	       #REQUIRED
	  %StandardAttributes;>

<!ELEMENT count     EMPTY>
<!ATTLIST count 
	  groupby  CDATA	       #REQUIRED
	  countattr  CDATA	       #REQUIRED
	  %StandardAttributes;>

<!ELEMENT select  (and | or | not | pred)>
<!ATTLIST select 
	  %StandardAttributes;>

<!ELEMENT dup  EMPTY>
<!ATTLIST dup
          branch   CDATA    #REQUIRED 
	  %StandardAttributes;>

<!ELEMENT union  EMPTY>
<!ATTLIST union
         id ID                         #REQUIRED
         physical  CDATA               #IMPLIED 
         input    IDREFS               #REQUIRED
	 %StandardAttributes;>


<!--
        "left" and "right" are lists of variables used in an equijoin.
	It's necessary to specify them when using a hash join 
	implementation.
-->
<!ELEMENT join     (pred)? >
<!ATTLIST join
          id       ID                   #REQUIRED
	  left	   CDATA		#IMPLIED
	  right	   CDATA		#IMPLIED
	  physical CDATA		""
          input    IDREFS               #REQUIRED
	  %PositionAttributes;>

<!ELEMENT and     (and | or | not | pred)+>
<!ELEMENT or      (and | or | not | pred)+>
<!ELEMENT not     (and | or | not | pred)>

<!ELEMENT pred    (number | string | var)+>
<!ATTLIST pred
          op      (lt | gt | le | ge | ne | eq)  #REQUIRED>
<!ELEMENT number  EMPTY>
<!ATTLIST number
          value   CDATA                #REQUIRED>

<!ELEMENT string  EMPTY>
<!ATTLIST string 
          value   CDATA                #REQUIRED>

<!ELEMENT var  EMPTY>
<!ATTLIST var
          value   CDATA                #REQUIRED>

<!ELEMENT dtdscan  (url)+>
<!ATTLIST dtdscan 
          id       ID           #REQUIRED
          physical CDATA        #IMPLIED
	  %PositionAttributes;>

<!ELEMENT resource EMPTY>
<!ATTLIST resource 
          id       ID           #REQUIRED
          urn      CDATA        #REQUIRED
          physical CDATA        #IMPLIED
	  %PositionAttributes;>

<!-- Constant is a pseudo-operator for including a document verbatim 
     as a source in a query plan. The document should be included 
     as a CDATA section, to avoid costly parse phases. Important
     caveat: CDATA sections cannot nest! -->
  
<!ELEMENT constant  (#PCDATA)>
<!ATTLIST constant 
          id       ID           #REQUIRED
          physical CDATA        #IMPLIED
	  %PositionAttributes;>


<!ELEMENT send EMPTY>
<!ATTLIST send 
          id       ID           #REQUIRED
          physical CDATA        #IMPLIED
          query_id CDATA        #REQUIRED
	  %PositionAttributes;>

<!-- Send results of the query back to the client -->
<!ELEMENT display EMPTY>
<!ATTLIST display 
          id       ID           #REQUIRED
          physical CDATA        #IMPLIED
          query_id CDATA        #REQUIRED
          client_location CDATA #REQUIRED
	  %PositionAttributes;>

<!-- Top n tuples --> 
<!ELEMENT topn EMPTY>
<!ATTLIST topn
	  order	   (descending|ascending) "descending"
	  comparison (alphabetic|numeric) "alphabetic"
	  sort_by  CDATA        #REQUIRED
          number   CDATA        #REQUIRED        
	  %StandardAttributes;>

<!ELEMENT firehosescan  EMPTY>
<!ATTLIST firehosescan 
          id       ID           #REQUIRED
	  host	   CDATA	#REQUIRED
	  port	   CDATA	#REQUIRED
	  rate	   CDATA	#REQUIRED
	  type	   (gen | file) "gen"
	  desc     CDATA        #REQUIRED
	  iters    CDATA        #REQUIRED
	  %PositionAttributes;>


<!ELEMENT url        EMPTY >
<!ATTLIST url
          value    CDATA        #REQUIRED>

<!-- If the clear attribute is set to "yes", construct will not keep
     any old attributes in the outgoing version of each tuple -->

<!ELEMENT construct  ANY>
<!ATTLIST construct  
          clear    (yes|no)     "no"
          %StandardAttributes;>

<!ELEMENT accumulate EMPTY>
<!ATTLIST accumulate
	  mergeAttr   CDATA	#REQUIRED
	  mergeTemplate CDATA	#REQUIRED
	  accumFileName CDATA	#REQUIRED
	  initialAccumFile CDATA #IMPLIED
	  clear     (true | false) "false"
	  %StandardAttributes;>
